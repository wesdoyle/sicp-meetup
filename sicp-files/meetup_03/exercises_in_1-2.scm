;;; Exercise 1.12. The following pattern of numbers is called Pascal's triangle.

;;; The numbers at the edge of the triangle are all 1, and each number inside
;;; the triangle is the sum of the two numbers above it.35

;;; Write a procedure that computes elements of Pascal's triangle by
;;; means of a recursive process. If a number lies outside of the triangle,
;;; return 0 (this makes sense if we view pascal as the combination function ).
;;; Start counting rows and columns from 0.

(define (pascal row col)
  "Tree recursive process for computing the element of Pascal's triangle at `row' and `col'.
This is the solution to exercise 1.12"
  (cond ((not (<= 0 col row)) 0)
         ((= row 0) 1)
         (else (+ (pascal (- row 1) col)
                  (pascal (- row 1) (- col 1))))))

;; Just for fun
(define (pascal-elements rows)
  "Returns a list of lists where each nested list is a row of Pascal's triangle, up to `rows'"
 ;; Named let syntax as a looping construct https://people.csail.mit.edu/jaffer/r5rs_6.html#IDX130
 ;; Used a few times in this file
  (let iter ((count (- rows 1))
             (results '()))
    (cond ((= count 0) (cons '(1) results))
          (else
           (iter (- count 1)
                 (cons (let row-iter ((row-els '())
                                      (col count))
                         (if (< col 0)
                             row-els
                             (row-iter (cons (pascal count col) row-els) (- col 1))))
                       results))))))

(define (display-pascals-triangle rows)
  "Prints `rows' of Pascal's triangle. Note that the alignment breaks down once elements > 10 (at 6 or more rows)"
  (define (format-row row i)
    (indent (- rows i)
            (string-join (map number->string row)
                         " ")))
  (let* ((triangle (pascal-elements rows))
         (string-rows (map format-row
                           triangle
                           (iota rows))))
    (display (string-join string-rows "\n"))
    (newline)))


;;; Exercise 1.15: The sine of an angle (specified in radians) can be computed by
;;; making use of the approximation sin ⁡ x ≈ x if x is sufficiently small, and the
;;; trigonometric identity
;;; sin ⁡ x = 3 sin ⁡ x 3 − 4 sin 3 ⁡ x 3
;;; to reduce the size of the argument of sin. (For purposes of this exercise an
;;; angle is considered “sufficiently small” if its magnitude is not greater than
;;; 0.1 radians.) These ideas are incorporated in the following procedures:

(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))


;; Questions
;; 1. How many times is the procedure p applied when (sine 12.15) is evaluated?

;;

(define (count-p-applications-in-sine angle)
  (define count 0)
  (define (p-counted x)
    (set! count (+ 1 count))
    (- (* 3 x) (* 4 (cube x))))
  (define (sine-with-p-counted angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p-counted (sine-with-p-counted (/ angle 3.0)))))
  (let ((s (sine-with-p-counted angle)))
    (newline))
  count)

;; 2. What is the order of growth in space and number of steps (as a function of a ) used by the process generated by the sine procedure when (sine a) is evaluated?
;; ~logn

;;; Utilities
(define (string-repeat n string)
  "Creates a string consisting of `string' repeated `n' times. Returns an empty string when `n' <= 0"
  (let loop ((res "")
             (count n))
    (if (<= count 0)
        res
        (loop (string-append res string)
              (- count 1)))))

(define (indent spaces str)
  (string-append (string-repeat spaces " ")
                 str))

(define (log-b b x)
  (/ (log x) (log b)))

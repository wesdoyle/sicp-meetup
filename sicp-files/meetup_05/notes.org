#+title: Notes

* Constructing Procedures Using Lambda
=lambda= creates procedures in the same way as =define= â€” the only differences is that a procedure created using =lambda= is not automatically associated with a name in the environment.

#+begin_src scheme
(define (plus4 x) (+ x 4))
#+end_src
is equivalent to
#+begin_src scheme
(define plus4 (lambda (x) (+ x 4)))
#+end_src

The nice thing about lambdas is that they allow us to pass trivial procedures as arguments without having to name them. Example with =pi-sum=:
#+begin_src scheme
;; `sum' function given in last section
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
#+end_src

Like any expression whose value is a procedure, a procedure created using =lambda= can be used as the operator in a combination:
#+begin_src scheme
(define (square x) (* x x))

((lambda (x y z) (+ x y (square z))) 1 2 3)
#+end_src

#+RESULTS:
: 12

* Using let to create local variables
As a side effect of lambda's ability to be used as the operator in a combination, they can also be used as a way to create local variables:
#+begin_src scheme
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
#+end_src
[[file:local_vars_with_lambda.png]]

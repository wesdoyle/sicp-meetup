#+title: Notes

* Constructing Procedures Using Lambda
=lambda= creates procedures in the same way as =define= — the only differences is that a procedure created using =lambda= is not automatically associated with a name in the environment.

#+begin_src scheme
(define (plus4 x) (+ x 4))
#+end_src
is equivalent to
#+begin_src scheme
(define plus4 (lambda (x) (+ x 4)))
#+end_src

The nice thing about lambdas is that they allow us to pass trivial procedures as arguments without having to name them. Example with =pi-sum=:
#+begin_src scheme
;; `sum' function given in last section
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
#+end_src

Like any expression whose value is a procedure, a procedure created using =lambda= can be used as the operator in a combination:
#+begin_src scheme
(define (square x) (* x x))

((lambda (x y z) (+ x y (square z))) 1 2 3)
#+end_src

#+RESULTS:
: 12

* Using let to create local variables
As a side effect of their ability to be used as the operator in a combination, lambda expressions can also be used to create local variables:
#+begin_src scheme
(define (f x y)
  ((lambda (a b) ;; a and b are names scoped to the body of the procedure produced by lambda
     (+ (* x (square a))
        (* y b)
        (* a b)))
   ;; arguments to the lambda
   (+ 1 (* x y)) ;; the value of `a` in the lambda body
   (- 1 y))) ;; the value of `b` in the lambda body
#+end_src
[[file:local_vars_with_lambda.png]]

The =let= special form is a more convenient way to use this pattern:
#+begin_src scheme
(define (f x y)
  (let ((a (+ 1 (* x y))) ;; the names of local variables and their values are colocated
        (b (- y 1)))
    (+ (* x (square a))
        (* y b)
        (* a b))))
#+end_src

=let= is just syntactic sugar for the lambda pattern in the first example, which means it doesn't require the interpreter to implement any additional constructs to support it. In fact, one of the cool things about Scheme and other lisps is the ability to define new syntax from existing primitives using macros; we can define our own =let=:

#+begin_src scheme
(define-macro (our-let bindings . body)
  `((lambda ,(map car bindings)
      ,@body)
    ,@(map cadr bindings)))

(our-let ((a 1)
          (b 2))
 (+ a b))

;; 3
#+end_src

#+RESULTS:
: 3

*NOTE*: Macros aren't used much in SICP, so it isn't important to fully understand the =our-let= example. There's an interesting parallel here, though! Like procedures abstract compound operations (consisting of primitive operations or other procedures), high-level language constructs like =let= abstract /other language constructs/.
* Chapter 2: Building Abstractions with Data
In the first chapter, we've focused on simple data (numbers) and procedure; chapter 2 introduces more complex, /compound/ data structures.

#+begin_quote
Why do we want compound data in a programming language? For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language.
#+end_quote


** Rational numbers
We can conceptualize a rational number as a pair of two numbers: a numerator and a denominator. Conveniently, Scheme provides a primitive data structure—the /pair/ — that we can use to represent these. At minimum, our mini language for working with rational numbers must be comprised of a few procedures that act as a convential /interface/ to the rational number data structure: =make-rat=, =numer= (selector for a rational number's numerator), and =denom= (selector for a rational number's denominator)

Example implementation using the /pair/ data structure:
#+begin_src scheme
(define (make-rat n d)
  (cons n d))

(define (numer rat)
  (car rat))

(define (denom rat)
  (cdr rat))
#+end_src

*NOTE*: =cons= is the pair constructor. It takes two arguments: the first is the first member of the pair; the second argument is the second member of the pair. The first member of a pair can be access by passing the pair to the =car= procedure. The second member of a pair can be accessed by using the =cdr= procedure.

Given these basic procedures for interacting with our basic data structure for rational numbers, we can define further operations: addition, subtraction, multiplication, division, and equality:
#+begin_src scheme
(define (make-rat n d)
  (cons n d))

(define (numer rat)
  (car rat))

(define (denom rat)
  (cdr rat))

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
#+end_src

We can define a procedure to more easily visualize our rational number representation:
#+begin_src scheme
(define (print-rat rat)
  (newline)
  (display (numer rat))
  (display "/")
  (display (denom rat)))
#+end_src
